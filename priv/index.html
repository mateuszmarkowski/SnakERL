<!DOCTYPE HTML>
<html>
<head>
<script type="text/javascript">
var ws = new Object;

class SnakeState {}

SnakeState.ACTIVE = 'A';
SnakeState.COLLISION = 'C';

class GameState {}

GameState.ACTIVE = 'A';
GameState.PENDING = 'P';

class Snake {
	constructor(id, state, segments, color) {
		this.id = id;
		this.state = state;
		this.segments = segments;
		this.color = color;
	}
}

class Treasure {
	constructor(x, y, type) {
		this.x = x;
		this.y = y;
		this.type = type;
	}
}

class Game {
	constructor(context) {
		this.snakes = {};
		this.treasures = [];
		this.context = context;
		this.sizeMultiplier = 10;
		this.state = GameState.PENDING;
	}
	
	getRandomColor () {
		var colors = [
			'blue',
			'pink',
			'purple',
			'green',
			'black',
			'pink',
			'gray',
			'white',
		];
		
		return colors[Math.floor((Math.random(colors.length) * colors.length))];
	}
	
	addOrUpdateSnake(snake) {
		if (snake.id in this.snakes) {
			this.snakes[snake.id].segments = snake.segments;
			this.snakes[snake.id].state = snake.state;
		} else {
			this.snakes[snake.id] = snake;
			this.snakes[snake.id].color = this.getRandomColor();
		}
		
		this.haveWeLost();
	}
	
	haveWeLost() {
		if (this.playerId in this.snakes && this.snakes[this.playerId].state == SnakeState.COLLISION) {
			alert('YOU LOST!');
		}
	}
	
	handleMessage(text) {
		var message = MessageDeserializer.deserialize(text);
		
		if (typeof message != 'object') {
			return;
		}
		
		switch (message.constructor.name) {
			case 'UpdateMessage':
				var snakeIds = [];
			
				if (this.playerId == undefined) {
					return;
				}
			
				for (var snake of message.snakes) {
					this.addOrUpdateSnake(snake);
					
					snakeIds.push(snake.id);
				}
				
				//remove snakes which haven't been returned
				for (var snakeId in this.snakes) {
					if (snakeIds.indexOf(snakeId) < 0) {
						delete this.snakes[snakeId];
					}
				}
				
				this.treasures = message.treasures;

				this.render();
			break;
			
			case 'IdMessage':
				this.playerId = message.id;
			break;
		}
	}
	
	coordsToSegment(x, y) {		
		return [
			x * this.sizeMultiplier,
			y * this.sizeMultiplier,
			this.sizeMultiplier,
			this.sizeMultiplier
		];
	}
	
	render() {
		this.context.fillStyle = 'red';
		this.context.fillRect(0, 0, 800, 400);
		
		for (var snakeId in this.snakes) {
			var snake = this.snakes[snakeId];
			
			this.context.fillStyle = snake.color;
			
			for (var segment of snake.segments) {				
				this.context.fillRect.apply(this.context, this.coordsToSegment(segment[0], segment[1]));
			}
		}
		
		this.context.fillStyle = 'white';
		
		for (var treasure of this.treasures) {
			this.context.fillRect.apply(this.context, this.coordsToSegment(treasure.x, treasure.y));
		}
	}
}

class UpdateMessage {
	constructor(snakes, treasures) {
		this.snakes = snakes;
		this.treasures = treasures;
	}
}

class IdMessage {
	constructor(id) {
		this.id = id;
	}
}

class MessageDeserializer {
	static deserialize(text) {
		switch (text.slice(0, 2)) {
			case 'D#':
				var updateTexts = text.slice(2).split('_'),
					treasureTexts = updateTexts[1].split('|'),
					snakeTexts = updateTexts[2].split('|'),
					snakes = [],
					treasures = [];

				for (var snakeText of snakeTexts) {
					var snakeParts = snakeText.split('='),
						snakeId = snakeParts[0],
						snakeState = snakeParts[1],
						segmentTexts = snakeParts[2].split(';'),
						segments = [],
						snake;
					
					segments = segmentTexts.map(function (segmentText) {
						var XY = segmentText.split(',');
						
						return [parseFloat(XY[0]), parseFloat(XY[1])];
					});
					
					snake = new Snake(snakeId, snakeState, segments);
					
					snakes.push(snake);
				}
				
				for (var treasureText of treasureTexts) {		
					if (treasureText.length == 0) {
						continue;
					}
								
					var treasureParts = treasureText.split('='),
						treasureType = treasureParts[0],
						XY = treasureParts[1].split(','),
						treasure;
				
					treasure = new Treasure(parseFloat(XY[0]), parseFloat(XY[1]), treasureType);
					
					treasures.push(treasure);
				}
				
				return new UpdateMessage(snakes, treasures);
			break;
			
			case 'L#':
				
			break;
			
			//the server tells us what our ID is
			case 'I#':
				return new IdMessage(text.slice(2));
			break;
			
			default:
			
			break;
			
		}
	}
}

function start()
{
	ws.send("S#20,20");
}
function direction(dir)
{
	ws.send("D#"+dir);
}
function list()
{
	ws.send("L#");
}
function open()
{
	var canvas = document.getElementById('board');
	
	if (!("WebSocket" in window)) {
		alert("This browser does not support WebSockets");
		return;
	}
	/* @todo: Change to your own server IP address */
	ws = new WebSocket("ws://localhost:8080/websocket");

	ws.onopen = function() {
		console.log('Connected');
	};
	
	var game = new Game(canvas.getContext('2d'));
	
	ws.onmessage = function (evt)
	{
		var received_msg = evt.data;
		console.log("Received: " + received_msg);
		
		game.handleMessage(received_msg);
	};
	
	ws.onclose = function()
	{
		console.log('Connection closed');
	};
	
	window.addEventListener('keydown', function (e) {
		switch (e.keyCode) {
			case 38:
				direction(1);
			break;
			
			case 40:
				direction(3);
			break;
			
			case 37:
				direction(4);
			break;
			
			case 39:
				direction(2);
			break;
			
		}
	});
}

</script>
</head>
<body>
<div id="sse">
   <a href="javascript:open()">Open websocket connection</a><br/>
   <a href="javascript:start()">Start game</a><br/>
   <a href="javascript:list()">List games</a><br/>
   <a href="javascript:direction(1)">Up</a><br/>
   <a href="javascript:direction(3)">Down</a><br/>
   <a href="javascript:direction(2)">Right</a><br/>
   <a href="javascript:direction(4)">Left</a><br/>
</div>
<div id="msgs">
</div>

<canvas width="200" height="200" id="board">
</canvas>
</body>
</html>
